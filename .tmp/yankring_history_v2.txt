,V
}  /* -----  end of method Vector3::Vector3  (constructor)  ----- */,V
{,V
Vector3::Vector3 (),V
 */,V
 *--------------------------------------------------------------------------------------,V
 * Description:  constructor,V
 *      Method:  Vector3,V
 *       Class:  Vector3,V
/*,V
    for(int i = 0; i < size; i++ ) {        p[i] = 0    },V
*,v
#define VECTOR3_ERROR -1;/*  * ===================================================================================== *        Class:  Node *  Description:  Contains the data member of the node * ===================================================================================== */template < class T >class Node{    public:        // ====================  LIFECYCLE     =======================================        Node ();                                    /* generic constructor      */		Node(T d, Node* nxt=NULL, Node* prev=NULL); /* constructor      */        Node ( const Node &n );                     /* copy constructor */        ~Node ();                                   /* destructor       */        /* ====================  ACCESSORS     ======================================= */		T get_data();		void set_data(T d);		Node& get_next();		Node& get_prev();		void set_next(Node n);		void set_prev(Node n);        /* ====================  OPERATORS     ======================================= */        Node& operator = ( const Node &other ); // assignment operator		Node& operator+=( const Node& other );		Node& operator-=( const Node& other );		Node& operator*=( const Node& other );		Node& operator+( const Node& other );		Node& operator-( const Node& other );		Node& operator*( const Node& other );        friend ostream& operator<<(ostream& out, Node<T>& n) {            out << n.get_data();            return out;        }    private:        /* ====================  DATA MEMBERS  ======================================= */		T data;		Node *next;		Node *previous;}; /* -----  end of template class Node  ----- *//*  * ===================================================================================== *        Class:  Vector3 *  Description:  Vector class that contains the x,y,z and w values used in opengl * ===================================================================================== */template < class T >class Vector3{    public:        // ====================  LIFECYCLE     =======================================        Vector3 ();                   /* generic constructor      */		Vector3(T x, T y, T z);       /* constructor      */        Vector3 ( const Vector3 &v ); /* copy constructor */        ~Vector3 ();                  /* destructor       */        /* ====================  ACCESSORS     ======================================= */		void insert(T v, int pos);		int get_size();		Node<T>& get_head();		Node<T>& get_tail();        /* ====================  OPERATORS     ======================================= */        Vector3& operator = ( const Vector3 &other ); // assignment operator		T operator[](int pos);		Vector3& operator+=( const Vector3& other );		Vector3& operator-=( const Vector3& other );		Vector3& operator+( const Vector3& other );		Vector3& operator-( const Vector3& other );		T operator&( const Vector3& other );		Vector3& operator*( const Vector3& other );        friend ostream& operator<<(ostream& out, Vector3& v) {            out << "[ " << v.get_head() << ", " << v.get_head().get_next() << ", " << v.get_tail() << " ]";            return out;        }    private:        /* ====================  DATA MEMBERS  ======================================= */		Node<T> head;		Node<T> tail;		static const int size = 4;		enum value_code {			e0,			e1,			e2,			e3,			eNone		};		typedef enum value_code Value_code;        /* ====================  METHODS       ======================================= */		inline value_code hashit ( int const i )		{			if(i == 0) return e0;			if(i == 1) return e1;			if(i == 2) return e2;			if(i == 3) return e3;			return eNone;		}}; /* -----  end of template class Vector3  ----- *//* ***************************************************************************** *                       Node Method Definitions                             * ***************************************************************************** */template <class T>inline Node<T>::Node()  {    this = Node(0.0);}template <class T>inline Node<T>::Node(T d, Node* nxt, Node* prev) {	data = d;	next = nxt;	previous = prev;}template <class T>inline Node<T>::Node( const Node& n ) {	data = n.data;	next = n.next;	previous = n.previous;}template <class T>inline Node<T>::~Node() {	next = NULL;	previous = NULL;}template <class T>T Node<T>::get_data() {	return data;}template <class T>void Node<T>::set_data(T d) {	data = d;}template <class T>Node<T>& Node<T>::get_next() {	return next;}template <class T>Node<T>& Node<T>::get_prev() {	return previous;}template <class T>void Node<T>::set_next(Node n) {	next = &n;}template <class T>void Node<T>::set_prev(Node n) {	previous = &n;}template <class T>Node<T>& Node<T>::operator=( const Node& other ) {	if (this == &other) {		return *this;	} else {		data = other.data;		next = other.next;		previous = other.previous;	}	return *this;}template <class T>Node<T>& Node<T>::operator+=( const Node& other ) {	data += other.get_data();}template <class T>Node<T>& Node<T>::operator-=( const Node& other ) {	data -= other.data;}template <class T>Node<T>& Node<T>::operator*=( const Node& other ) {	data *= other.data;}template <class T>Node<T>& Node<T>::operator+( const Node& other ) {	data = data + other.data;}template <class T>Node<T>& Node<T>::operator-( const Node& other ) {	data = data - other.data;}template <class T>Node<T>& Node<T>::operator*( const Node& other ) {	data = data * other.data;}/* ***************************************************************************** *					End Node Method Definitions								 * ***************************************************************************** *//* ***************************************************************************** *                       Vector3 Method Definitions                             * ***************************************************************************** */template <class T>Vector3<T>::Vector3() {    head = Node<T>(0);    tail = Node<T>(0);}template <class T>Vector3<T>::Vector3(T x, T y, T z) {    head = Node<T>(x);	Node<T> node1 = Node<T>(y);	tail = Node<T>(z);	head.set_prev(tail);	head.set_next(node1);	node1.set_prev(head);	node1.set_next(tail);	tail.set_prev(node1);	tail.set_next(head);}//template <class T>//Vector3<T>::Vector3( const Vector3& v ) { } template <class T>Vector3<T>::~Vector3() { }template <class T>void Vector3<T>::insert(T v, int pos) {	switch(hashit(pos)) {		case e0:			head.set_data(v);			break;		case e1:			head.get_next().set_data(v);			break;		case e2:			tail.set_data(v);			break;		default:			break;	}}template <class T>int Vector3<T>::get_size() {	return size;}template <class T>Node<T>& Vector3<T>::get_head() {	return *head;}template <class T>Node<T>& Vector3<T>::get_tail() {	return tail;}template <class T>T Vector3<T>::operator[](int pos) {	switch(hashit(pos)) {		case e0:			return head.get_data();		case e1:			return head.get_next().get_data();		case e2:			return tail.get_data();		default:			break;	}	return VECTOR3_ERROR;}template <class T>Vector3<T>& Vector3<T>::operator=( const Vector3& other ) {	if(this == &other) {		return *this;	} else {		head = other.head;		tail = other.tail;	}	return *this;}template <class T>Vector3<T>& Vector3<T>::operator+=( const Vector3& other ) {            Node<T> other_h = other[0];    Node<T> other_n = other[1];    Node<T> other_t = other[2];	head+=other_h;	head.get_next()+=other_n;	tail+=other_t;	return this;}template <class T>Vector3<T>& Vector3<T>::operator-=( const Vector3& other) {	head-=other.head;	head->next-=other.head->next;	tail-=other.tail;	return *this;}template <class T>Vector3<T>& Vector3<T>::operator+( const Vector3& other ) {	head = head + other.get_head();	Node<T> _v1 = head.next;	Node<T> v1 = other.get_head()->next;	_v1 = _v1 + v1;	tail = tail + other.get_tail();	return *this;}template <class T>Vector3<T>& Vector3<T>::operator-( const Vector3& other ) {	head = head - other->get_head();	Node<T> _v1 = head->next;	Node<T> v1 = other->get_head()->next;	_v1 = _v1 - v1;	tail = tail - other->get_tail();	return *this;}template <class T>T Vector3<T>::operator&(const Vector3& other ) {	T x = head * other->get_head();	T y = head->get_next() * other->get_head()->get_next();	T z = tail * other->get_tail();	return (x + y + z);}template <class T>Vector3<T>& Vector3<T>::operator*(const Vector3& other ) {	}#endif,V
#ifndef __Vector3_INC#define __Vector3_INC#include <iostream>using namespace std;#define VECTOR3_ERROR -1;/*  * ===================================================================================== *        Class:  Node *  Description:  Contains the data member of the node * ===================================================================================== */template < class T >class Node{    public:        // ====================  LIFECYCLE     =======================================        Node ();                                    /* generic constructor      */		Node(T d, Node* nxt=NULL, Node* prev=NULL); /* constructor      */        Node ( const Node &n );                     /* copy constructor */        ~Node ();                                   /* destructor       */        /* ====================  ACCESSORS     ======================================= */		T get_data();		void set_data(T d);		Node& get_next();		Node& get_prev();		void set_next(Node n);		void set_prev(Node n);        /* ====================  OPERATORS     ======================================= */        Node& operator = ( const Node &other ); // assignment operator		Node& operator+=( const Node& other );		Node& operator-=( const Node& other );		Node& operator*=( const Node& other );		Node& operator+( const Node& other );		Node& operator-( const Node& other );		Node& operator*( const Node& other );        friend ostream& operator<<(ostream& out, Node<T>& n) {            out << n.get_data();            return out;        }    private:        /* ====================  DATA MEMBERS  ======================================= */		T data;		Node *next;		Node *previous;}; /* -----  end of template class Node  ----- *//*  * ===================================================================================== *        Class:  Vector3 *  Description:  Vector class that contains the x,y,z and w values used in opengl * ===================================================================================== */template < class T >class Vector3{    public:        // ====================  LIFECYCLE     =======================================        Vector3 ();                   /* generic constructor      */		Vector3(T x, T y, T z);       /* constructor      */        Vector3 ( const Vector3 &v ); /* copy constructor */        ~Vector3 ();                  /* destructor       */        /* ====================  ACCESSORS     ======================================= */		void insert(T v, int pos);		int get_size();		Node<T>& get_head();		Node<T>& get_tail();        /* ====================  OPERATORS     ======================================= */        Vector3& operator = ( const Vector3 &other ); // assignment operator		T operator[](int pos);		Vector3& operator+=( const Vector3& other );		Vector3& operator-=( const Vector3& other );		Vector3& operator+( const Vector3& other );		Vector3& operator-( const Vector3& other );		T operator&( const Vector3& other );		Vector3& operator*( const Vector3& other );        friend ostream& operator<<(ostream& out, Vector3& v) {            out << "[ " << v.get_head() << ", " << v.get_head().get_next() << ", " << v.get_tail() << " ]";            return out;        }    private:        /* ====================  DATA MEMBERS  ======================================= */		Node<T> head;		Node<T> tail;		static const int size = 4;		enum value_code {			e0,			e1,			e2,			e3,			eNone		};		typedef enum value_code Value_code;        /* ====================  METHODS       ======================================= */		inline value_code hashit ( int const i )		{			if(i == 0) return e0;			if(i == 1) return e1;			if(i == 2) return e2;			if(i == 3) return e3;			return eNone;		}}; /* -----  end of template class Vector3  ----- *//* ***************************************************************************** *                       Node Method Definitions                             * ***************************************************************************** */template <class T>inline Node<T>::Node()  {    this = Node(0.0);}template <class T>inline Node<T>::Node(T d, Node* nxt, Node* prev) {	data = d;	next = nxt;	previous = prev;}template <class T>inline Node<T>::Node( const Node& n ) {	data = n.data;	next = n.next;	previous = n.previous;}template <class T>inline Node<T>::~Node() {	next = NULL;	previous = NULL;}template <class T>T Node<T>::get_data() {	return data;}template <class T>void Node<T>::set_data(T d) {	data = d;}template <class T>Node<T>& Node<T>::get_next() {	return next;}template <class T>Node<T>& Node<T>::get_prev() {	return previous;}template <class T>void Node<T>::set_next(Node n) {	next = &n;}template <class T>void Node<T>::set_prev(Node n) {	previous = &n;}template <class T>Node<T>& Node<T>::operator=( const Node& other ) {	if (this == &other) {		return *this;	} else {		data = other.data;		next = other.next;		previous = other.previous;	}	return *this;}template <class T>Node<T>& Node<T>::operator+=( const Node& other ) {	data += other.get_data();}template <class T>Node<T>& Node<T>::operator-=( const Node& other ) {	data -= other.data;}template <class T>Node<T>& Node<T>::operator*=( const Node& other ) {	data *= other.data;}template <class T>Node<T>& Node<T>::operator+( const Node& other ) {	data = data + other.data;}template <class T>Node<T>& Node<T>::operator-( const Node& other ) {	data = data - other.data;}template <class T>Node<T>& Node<T>::operator*( const Node& other ) {	data = data * other.data;}/* ***************************************************************************** *					End Node Method Definitions								 * ***************************************************************************** *//* ***************************************************************************** *                       Vector3 Method Definitions                             * ***************************************************************************** */template <class T>Vector3<T>::Vector3() {    head = Node<T>(0);    tail = Node<T>(0);}template <class T>Vector3<T>::Vector3(T x, T y, T z) {    head = Node<T>(x);	Node<T> node1 = Node<T>(y);	tail = Node<T>(z);	head.set_prev(tail);	head.set_next(node1);	node1.set_prev(head);	node1.set_next(tail);	tail.set_prev(node1);	tail.set_next(head);}//template <class T>//Vector3<T>::Vector3( const Vector3& v ) { } template <class T>Vector3<T>::~Vector3() { }template <class T>void Vector3<T>::insert(T v, int pos) {	switch(hashit(pos)) {		case e0:			head.set_data(v);			break;		case e1:			head.get_next().set_data(v);			break;		case e2:			tail.set_data(v);			break;		default:			break;	}}template <class T>int Vector3<T>::get_size() {	return size;}template <class T>Node<T>& Vector3<T>::get_head() {	return *head;}template <class T>Node<T>& Vector3<T>::get_tail() {	return tail;}template <class T>T Vector3<T>::operator[](int pos) {	switch(hashit(pos)) {		case e0:			return head.get_data();		case e1:			return head.get_next().get_data();		case e2:			return tail.get_data();		default:			break;	}	return VECTOR3_ERROR;}template <class T>Vector3<T>& Vector3<T>::operator=( const Vector3& other ) {	if(this == &other) {		return *this;	} else {		head = other.head;		tail = other.tail;	}	return *this;}template <class T>Vector3<T>& Vector3<T>::operator+=( const Vector3& other ) {            Node<T> other_h = other[0];    Node<T> other_n = other[1];    Node<T> other_t = other[2];	head+=other_h;	head.get_next()+=other_n;	tail+=other_t;	return this;}template <class T>Vector3<T>& Vector3<T>::operator-=( const Vector3& other) {	head-=other.head;	head->next-=other.head->next;	tail-=other.tail;	return *this;}template <class T>Vector3<T>& Vector3<T>::operator+( const Vector3& other ) {	head = head + other.get_head();	Node<T> _v1 = head.next;	Node<T> v1 = other.get_head()->next;	_v1 = _v1 + v1;	tail = tail + other.get_tail();	return *this;}template <class T>Vector3<T>& Vector3<T>::operator-( const Vector3& other ) {	head = head - other->get_head();	Node<T> _v1 = head->next;	Node<T> v1 = other->get_head()->next;	_v1 = _v1 - v1;	tail = tail - other->get_tail();	return *this;}template <class T>T Vector3<T>::operator&(const Vector3& other ) {	T x = head * other->get_head();	T y = head->get_next() * other->get_head()->get_next();	T z = tail * other->get_tail();	return (x + y + z);}template <class T>Vector3<T>& Vector3<T>::operator*(const Vector3& other ) {	}#endif,V
 ,v
	cout << "Vect2 is " << vect2 << endl;,V
		tail->~Node();,V
		head->~Node();,V
    this = Vector3(0.0,0.0,0.0);,V
	cout << "Vect is " << vect << endl;,V
	cout << "Vect[1] is " << vect[1] << endl;,V
	cout << "Vect[0] is " << vect[0] << endl;,V
	cout << "Vect1 is " << vect1 << endl;,V
),v
(,v
_,v
t,v
e,v
g,v
>,v
-,v
s,v
i,v
h,v
o,v
	Vector3<float> vect = Vector3<float>(0.0, 1.0, 0.5);,V
	cout << "Skeleton is " << skel;,V
n,v
c,v
=,v
w,v
#include "Vector3.h",V
#include "Vector3.h"/* ***************************************************************************** *                       Node Method Definitions                             * ***************************************************************************** */template <class T>Node<T>::Node()  {    this = Node(0.0);}template <class T>Node<T>::Node(T d, Node* nxt, Node* prev) {	data = d;	next = nxt;	previous = prev;}template <class T>Node<T>::Node( const Node& n ) {	data = n.data;	next = n.next;	previous = n.previous;}template <class T>Node<T>::~Node() {	next = NULL;	previous = NULL;}template <class T>T Node<T>::get_data() {	return data;}template <class T>void Node<T>::set_data(T d) {	data = d;}template <class T>Node<T>* Node<T>::get_next() {	return next;}template <class T>Node<T>* Node<T>::get_prev() {	return previous;}template <class T>void Node<T>::set_next(Node *n) {	next = n;}template <class T>void Node<T>::set_prev(Node *n) {	previous = n;}template <class T>Node<T>& Node<T>::operator=( const Node& other ) {	if (this == &other) {		return *this;	} else {		data = other.data;		next = other.next;		previous = other.previous;	}	return *this;}template <class T>Node<T>& Node<T>::operator+=( const Node& other ) {	data += other.data;}template <class T>Node<T>& Node<T>::operator-=( const Node& other ) {	data -= other.data;}template <class T>Node<T>& Node<T>::operator*=( const Node& other ) {	data *= other.data;}template <class T>Node<T>& Node<T>::operator+( const Node& other ) {	data = data + other.data;}template <class T>Node<T>& Node<T>::operator-( const Node& other ) {	data = data - other.data;}template <class T>Node<T>& Node<T>::operator*( const Node& other ) {	data = data * other.data;}/* ***************************************************************************** *					End Node Method Definitions								 * ***************************************************************************** *//* ***************************************************************************** *                       Vector3 Method Definitions                             * ***************************************************************************** */template <class T>Vector3<T>::Vector3() {    this = Vector3(0.0,0.0,0.0);}template <class T>Vector3<T>::Vector3(T x, T y, T z) {    head = new Node<T>(x);	Node<T> * node1 = new Node<T>(y);	tail = new Node<T>(z);	head->set_prev(tail);	head->set_next(node1);	node1->set_prev(head);	node1->set_next(tail);	tail->set_prev(node1);	tail->set_next(head);}template <class T>Vector3<T>::Vector3( const Vector3& v ) { } template <class T>Vector3<T>::~Vector3() { }template <class T>void Vector3<T>::insert(T v, int pos) {	switch(hashit(pos)) {		case e0:			head->set_data(v);			break;		case e1:			head->get_next()->set_data(v);			break;		case e2:			tail->set_data(v);			break;		default:			break;	}}template <class T>int Vector3<T>::get_size() {	return size;}template <class T>Node<T>* Vector3<T>::get_head() {	return head;}template <class T>Node<T>* Vector3<T>::get_tail() {	return tail;}template <class T>T Vector3<T>::operator[](int pos) {	switch(hashit(pos)) {		case e0:			return head->get_data();		case e1:			return head->get_next()->get_data();		case e2:			return tail->get_data();		default:			break;	}	return VECTOR3_ERROR;}template <class T>Vector3<T>& Vector3<T>::operator=( const Vector3& other ) {	if(this == &other) {		return *this;	} else {		head->~Node();		tail->~Node();		head = other.head;		tail = other.tail;	}	return *this;}template <class T>Vector3<T>& Vector3<T>::operator+=( const Vector3& other ) {	head+=other.head;	head->next+=other.head->next;	tail+=other.tail;	return *this;}template <class T>Vector3<T>& Vector3<T>::operator-=( const Vector3& other) {	head-=other.head;	head->next-=other.head->next;	tail-=other.tail;	return *this;}template <class T>Vector3<T>& Vector3<T>::operator+( const Vector3& other ) {	head = head + other->get_head();	Node<T> _v1 = head->next;	Node<T> v1 = other->get_head()->next;	_v1 = _v1 + v1;	tail = tail + other->get_tail();	return *this;}template <class T>Vector3<T>& Vector3<T>::operator-( const Vector3& other ) {	head = head - other->get_head();	Node<T> _v1 = head->next;	Node<T> v1 = other->get_head()->next;	_v1 = _v1 - v1;	tail = tail - other->get_tail();	return *this;}template <class T>T Vector3<T>::operator&(const Vector3& other ) {	T x = head * other->get_head();	T y = head->get_next() * other->get_head()->get_next();	T z = tail * other->get_tail();	return (x + y + z);}template <class T>Vector3<T>& Vector3<T>::operator*(const Vector3& other ) {	},V
#include "Vector3.cpp",V
        template <class T>,V
		friend ostream& operator<<( ostream& out, const Node<T>& n);,V
template <class T>ostream& operator<<(ostream& out, const Node<T>& n) {	out << n.get_data();	return out;},V
T,v
<,v
		friend ostream& operator<<( ostream& out, const Vector3<T>& v );,V
template <class T>ostream& operator<<(ostream& out, const Vector3<T>& v) {	out << "[ " << v.get_head() << ", " << v.get_head()->get_next() << ", " << v.get_tail();	return out;},V
N,v
(),v
z,v
:,v
Vector3(0.0,0.0,0.0),v
Node(0.0),v
a,v
L,v
U,v
};,V
        /* ====================  MUTATORS      ======================================= */,V
		void insert(T v, int pos);		const int get_size();,V
		Vector3& operator=( const Vector3& other );,V
		T operator[](int pos);		Vector3& operator=( const Vector3& other );		Vector3& operator+=( const Vector3& other );		Vector3& operator-=( const Vector3& other );		Vector3& operator+( const Vector3& other );		Vector3& operator-( const Vector3& other );		Vector3& operator&( const Vector3& other );		Vector3& operator*( const Vector3& other );,V
	public:,V
		~Vector3();,V
		Vector3( const Vector3& v);,V
		Vector3();,V
other,v
		Vector3(T x, T y, T z, T r);,V
        /* ====================  DATA MEMBERS  ======================================= */,V
        /* ====================  METHODS       ======================================= */,V
    protected:,V
class Vector3 {,V
template <class T>,V
	private:,V
		inline value_code hashit ( int const i )		{			if(i == 0) return e0;			if(i == 1) return e1;			if(i == 2) return e2;			if(i == 3) return e3;			return eNone;		},V
		enum value_code {			e0,			e1,			e2,			e3,			eNone		};		typedef enum value_code Value_code;,V
		Node *head;		Node *tail;		static const int size = 4;,V
		T get_data();		void set_data(T d);		Node* get_next();		Node* get_prev();		void set_next(Node *n);		void set_prev(Node *n);,V
		Node& operator=( const Node& other );,V
		Node& operator=( const Node& other );		Node& operator+=( const Node& other );		Node& operator-=( const Node& other );		Node& operator*=( const Node& other );		Node& operator+( const Node& other );		Node& operator-( const Node& other );		Node& operator*( const Node& other );,V
		~Node();,V
		Node( const Node& n);,V
		Node();,V
class Node {,V
		T data;		Node *next;		Node *previous;,V
		Node(T d, Node* nxt, Node* prev);,V
 *   Organization:  ,V
YOUR NAME (), ,v
    ,V
next,v
        inline Matrix_Member get_next() const;  /* get Matrix_Member */        void set_next(Matrix_Member *);         /* set Matrix_Member */,V
        /* ====================  METHODS       ======================================= */,V
#include <iostream>,V
YOUR,v
l,v
        ~Matrix ();                     l   /* destructor       */,V
,V
